import{_ as e,v as l,b as i,R as t}from"./chunks/framework.0bed0734.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/index.md","filePath":"vue/index.md"}'),a={name:"vue/index.md"},o=t('<h3 id="vue的基本原理" tabindex="-1">Vue的基本原理 <a class="header-anchor" href="#vue的基本原理" aria-label="Permalink to &quot;Vue的基本原理&quot;">​</a></h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用Object.defineProperty（vue3.0使用proxy）将它们转为getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p><h3 id="双向数据绑定的原理" tabindex="-1">双向数据绑定的原理 <a class="header-anchor" href="#双向数据绑定的原理" aria-label="Permalink to &quot;双向数据绑定的原理&quot;">​</a></h3><p>Vue.js是采用数据劫持结合发布-订阅模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:①在自身实例化时往属性订阅器(dep)里面添加自己②自身必须有一个update()方法③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新；视图交互变化(input)-&gt;数据model变更的双向绑定效果。</li></ol><h3 id="mvvm-mvc-mvp-的区别" tabindex="-1">MVVM MVC MVP 的区别 <a class="header-anchor" href="#mvvm-mvc-mvp-的区别" aria-label="Permalink to &quot;MVVM MVC MVP 的区别&quot;">​</a></h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时， 可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><ol><li><p>MVC MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。 其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据， 以及对相应数据的操作。并且 View 和 Model 应用了观察者模式， 当 Model 层发生改变的时候它会通知有关 View 层更新页面。 Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p></li><li><p>MVVM MVVM 分为 Model、View、ViewModel： Model 代表数据模型，数据和业务逻辑都在 Model 层中定义； View 代表 UI 视图，负责数据的展示； ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的， Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中 的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。 这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作 DOM。</p></li><li><p>MVP MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起， 当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的 Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中， View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦， Presenter 还包含了其他的响应逻辑。</p></li></ol><h3 id="vue模板编译原理" tabindex="-1">Vue模板编译原理 <a class="header-anchor" href="#vue模板编译原理" aria-label="Permalink to &quot;Vue模板编译原理&quot;">​</a></h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这个转化的过程，就称为模板编译。模板编译又分三个阶段，解析parse，优化optimize， 生成generate，最终生成可执行函数render。</p><ul><li>解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><li>优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><li>生成阶段：将最终的AST转化为render函数字符串。</li></ul><h3 id="slot的作用及原理" tabindex="-1">slot的作用及原理 <a class="header-anchor" href="#slot的作用及原理" aria-label="Permalink to &quot;slot的作用及原理&quot;">​</a></h3><p>slot 又名插槽，是 Vue 的内容分发机制，组件内部的模板引擎使用 slot 元素作为承载分发内容的出口。插槽 slot 是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot 又分三类，默认插槽、具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名插槽，当 slot 没有指定 name 属性值的时候一个默认显示插槽，一个组件内只有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有 name 属性的 slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p>实现原理：当子组件 vm 实例化时，获取到父组件传入的 slot 标签的内容，存放在 vm.$slot 中，默认插槽为 vm.$slot.default，具名插槽为 vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到 slot 标签，使用$slot 中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="nexttick原理及作用" tabindex="-1">$nextTick原理及作用 <a class="header-anchor" href="#nexttick原理及作用" aria-label="Permalink to &quot;$nextTick原理及作用&quot;">​</a></h3><p>原理：Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。nextTick 的核心是利用了如 Promise、 MutationObserver、 setImmediate、setTimeout的原生JavaScript方法来模拟对应的微/宏任务的实现，本质是为了利用JavaScript的这些异步回调任务队列来实现Vue。nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对DOM更新数据时机的后续逻辑处理。</p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，异步可以减少一些无用渲染。</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要。</li></ul><p>用到nextTick的场景：</p><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</li></ul><h3 id="子组件可以直接改变父组件的数据吗" tabindex="-1">子组件可以直接改变父组件的数据吗 <a class="header-anchor" href="#子组件可以直接改变父组件的数据吗" aria-label="Permalink to &quot;子组件可以直接改变父组件的数据吗&quot;">​</a></h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>Vue 提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><p>只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h3 id="对react和vue的理解并比较他们的异同" tabindex="-1">对React和Vue的理解并比较他们的异同 <a class="header-anchor" href="#对react和vue的理解并比较他们的异同" aria-label="Permalink to &quot;对React和Vue的理解并比较他们的异同&quot;">​</a></h3><p>相似之处：</p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了Virtual DOM（虚拟 DOM）提高重绘性能；</li><li>都有 props 的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p>不同之处：</p><ul><li>数据流：Vue 默认支持数据双向绑定，而 React 一直提倡单向数据流。</li><li>虚拟DOM：Vue2.x 开始引入&quot;Virtual DOM&quot;，消除了和 React 在这方面的差异， 但是在具体的细节还是有各自的特点。 <ul><li>Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul></li><li>组件化： <ul><li>Vue 鼓励写近似常规 HTML 的模板。写起来很接近标准 HTML 元素，只 是多了一些属性。React 推荐你所有的模板通用 JavaScript 的语法扩展——JSX书写。</li><li>具体来讲：React 中 render 函数是支持闭包特性的，所以 import 的 组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</li></ul></li><li>监听数据变化的实现原理不同：Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。React 默认是通过比较引用的方式进行的 ， 如果不优化 （PureComponent/shouldComponentUpdate）可能导致大量不必要的 vDOM 的重新渲染。这是因为 Vue 使用的是可变数据，而 React 更强调数据的不可变。</li><li>高阶组件： <ul><li>react 可以通过高阶组件（HOC）来扩展，而 Vue 需要通过 mixins 来扩展。</li><li>高阶组件就是高阶函数，而 React 的组件本身就是纯粹的函数，所以高阶函数对 React 来说易如反掌。相反 Vue.js 使用 HTML 模板创建视图组件，这时模板无法有效的编译，因此 Vue 不能采用 HOC 来实现。</li></ul></li><li>构建工具：两者都有自己的构建工具：React ==&gt; Create React APP，Vue ==&gt; vue-cli。</li><li>跨平台：React ==&gt; React Native，Vue ==&gt; Weex。</li></ul><h3 id="vue的优点" tabindex="-1">Vue的优点 <a class="header-anchor" href="#vue的优点" aria-label="Permalink to &quot;Vue的优点&quot;">​</a></h3><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</li><li>简单易学：国人开发，中文文档，不存在语言障碍，易于理解和学习；</li><li>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</li><li>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</li><li>运行速度更快：相比较于react而言，同样是操作虚拟dom，就性能而言， vue存在很大的优势。</li></ul>',33),r=[o];function u(d,n,p,s,V,c){return l(),i("div",null,r)}const h=e(a,[["render",u]]);export{m as __pageData,h as default};
