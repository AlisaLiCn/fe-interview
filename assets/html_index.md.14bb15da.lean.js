import{_ as l,r as i,a as e,Q as a}from"./chunks/framework.ce73d6a4.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"html/index.md","filePath":"html/index.md"}'),t={name:"html/index.md"},o=a('<h3 id="对html语义化的理解" tabindex="-1">对HTML语义化的理解 <a class="header-anchor" href="#对html语义化的理解" aria-label="Permalink to &quot;对HTML语义化的理解&quot;">​</a></h3><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO；</li><li>语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p>常见的语义化标签：</p><ul><li><header></header>头部 </li><li><nav></nav>导航栏 </li><li><section></section>区块，语义化的div </li><li><main></main>主要区域 </li><li><aside></aside>侧边栏 </li><li><footer></footer>底部 </li></ul><h3 id="在html中延迟加载javascript脚本的方式有哪些" tabindex="-1">在HTML中延迟加载JavaScript脚本的方式有哪些 <a class="header-anchor" href="#在html中延迟加载javascript脚本的方式有哪些" aria-label="Permalink to &quot;在HTML中延迟加载JavaScript脚本的方式有哪些&quot;">​</a></h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。js 延迟加载有助于提高页面加载速度。 一般有以下几种方式：</p><p>defer 属性：给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p><p>async 属性：给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p><p>动态创建 DOM 方式：动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p><p>使用 setTimeout 延迟方法：设置一个定时器来延迟加载js脚本文件。</p><p>让JS最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p><h3 id="重排与重绘概念及触发操作" tabindex="-1">重排与重绘概念及触发操作 <a class="header-anchor" href="#重排与重绘概念及触发操作" aria-label="Permalink to &quot;重排与重绘概念及触发操作&quot;">​</a></h3><p><strong>重排</strong>（回流）：当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为重排（回流）。 重排会触发渲染流程中重新布局、解析之后的一系列子阶段。需要更新完整的渲染流水线，所以开销也是最大的。</p><p>在触发重排的时候，由于浏览器渲染页面是基于流式布局的，所以当触发重排时，会导致周围的 DOM 元素重新排列，它的影响范围有两种：</p><ul><li>全局范围：从根节点开始，对整个渲染树进行重新布局</li><li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li></ul><p>触发重排的操作：</p><ul><li>页面的首次渲染</li><li>浏览器的窗口大小发生变化</li><li>元素的内容发生变化</li><li>元素的尺寸或者位置发生变化</li><li>元素的字体大小发生变化</li><li>激活CSS伪类</li><li>查询某些属性或者调用某些方法</li><li>添加或者删除可见的DOM元素</li></ul><p><strong>重绘</strong>：当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。 当触发重排时，一定会触发重绘，但是重绘不一定会引发重排。</p><p>会导致重绘的操作：</p><ul><li>color、background相关属性：background-color、background-image等</li><li>outline 相关属性：outline-color、outline-width、text-decoration</li><li>border-radius、visibility、box-shadow</li></ul><h3 id="如何减少重排与重绘" tabindex="-1">如何减少重排与重绘 <a class="header-anchor" href="#如何减少重排与重绘" aria-label="Permalink to &quot;如何减少重排与重绘&quot;">​</a></h3><p>减少重排与重绘的措施：</p><ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><li>不要使用table布局，一个小的改动可能会使整个table进行重新布局</li><li>使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。</li><li>避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发重排和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。浏览器针对页面的重排与重绘，进行了自身的优化——渲染队列浏览器会将所有的重排、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的重排、重绘变成一次重排重绘。将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次重排，变成了只触发一次重排。</li></ul><p>对于动画的优化：一般情况下，动画需要频繁的操作DOM，就会导致页面的性能问题，我们可以将动画的position属性设置为absolute或者fixed，将动画脱离文档流，这样他的重排就不会影响到页面了。</p><h3 id="使用documentfragment跟直接操作dom的区别是什么" tabindex="-1">使用documentFragment跟直接操作DOM的区别是什么 <a class="header-anchor" href="#使用documentfragment跟直接操作dom的区别是什么" aria-label="Permalink to &quot;使用documentFragment跟直接操作DOM的区别是什么&quot;">​</a></h3><p>MDN中对documentFragment的解释：DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的重新渲染，且不会对性能产生影响。</p><p>当我们把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。</p><h3 id="如何对项目中的图片进行优化" tabindex="-1">如何对项目中的图片进行优化 <a class="header-anchor" href="#如何对项目中的图片进行优化" aria-label="Permalink to &quot;如何对项目中的图片进行优化&quot;">​</a></h3><ol><li>不用图片。一些修饰类图片，可以用CSS去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用base64格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：</li></ol><ul><li>对于能够显示WebP格式的浏览器尽量使用WebP格式。因为WebP格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用PNG，其实对于大部分图标这类图片，可以使用SVG代替</li><li>照片使用JPEG</li></ul><h3 id="常见的图片格式及使用场景" tabindex="-1">常见的图片格式及使用场景 <a class="header-anchor" href="#常见的图片格式及使用场景" aria-label="Permalink to &quot;常见的图片格式及使用场景&quot;">​</a></h3><ul><li>BMP：是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</li><li>GIF：是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</li><li>JPEG：是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</li><li>PNG-8：是无损的、使用索引色的点阵图。PNG 是一种比较新的图片格式，PNG-8 是非常好的 GIF 格式替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8 具有更小的文件体积。除此之外，PNG-8 还支持透明度的调节，而 GIF 并不支持。除非需要动画的支持，否则没有理由使用 GIF 而不是 PNG-8。</li><li>PNG-24：是无损的、使用直接色的点阵图。PNG-24 的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小 要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8 大得多。</li><li>SVG：是无损的矢量图。SVG 是矢量图意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当放大 SVG 图片时，看到的还是线和曲线，而不会出现像素点。这意味着 SVG 图片在放大时，不会失真，所以它非常适合用来绘制 Logo、Icon 等。</li><li>WebP：是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 Chrome 浏览器和 Opera 浏览器支持 WebP 格式，兼容性不太好。</li></ul><p>比较：</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="如何提高web可访问性" tabindex="-1">如何提高web可访问性 <a class="header-anchor" href="#如何提高web可访问性" aria-label="Permalink to &quot;如何提高web可访问性&quot;">​</a></h3><p>参考题解：</p><p>提高web可访问性是一种能让更多的人使用我们的网站的做法，比如：让有视觉或听觉障碍的人群、移动设备用户、处于低速网络环境的人群也能正常使用网站。</p><p>web开发人员在开发的初期，就需要考虑可访问性相关的内容，以避免在后期难以改善。</p><p>提升可访问性的一些措施：</p><ul><li>书写语义化的HTML结构：例如：正确使用标题、段落等元素来构建文本内容；使用HTML5的语义元素进行页面布局(如<code>&lt;nav&gt;</code> <code>&lt;footer&gt;</code>等)；</li><li>保证键盘的可访问性：表单元素、按钮、超链接等本身能被键盘访问，如果为了更好的UI效果而使用其他元素来代替，可以利用tabindex属性来重新建立键盘的可访问性；</li><li>为非语义化元素添加WAI-ARIA属性，来提供额外的语义化和可访问性，例如：role=&quot;button&quot;等；</li><li>使用工具进行测试：例如：使用Mac系统自带的旁白功能，可以进行屏幕阅读效果的测试；使用在线工具或自动化工具对网站进行检测。</li></ul><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Accessibility" target="_blank" rel="noreferrer">MDN - 无障碍</a></li></ul>',44),r=[o];function n(d,s,c,u,p,h){return i(),e("div",null,r)}const P=l(t,[["render",n]]);export{b as __pageData,P as default};
