import{_ as l,S as i,N as e,y as a}from"./chunks/framework.d7f66f09.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"browser/index.md","filePath":"browser/index.md"}'),r={name:"browser/index.md"},o=a('<h3 id="进程和线程" tabindex="-1">进程和线程 <a class="header-anchor" href="#进程和线程" aria-label="Permalink to &quot;进程和线程&quot;">​</a></h3><ul><li>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</li><li>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。</li></ul><p>进程和线程关系：</p><ol><li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li><li>线程之间共享进程中的数据。</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li><li>进程之间的内容相互隔离。</li></ol><h3 id="浏览器的多进程架构" tabindex="-1">浏览器的多进程架构 <a class="header-anchor" href="#浏览器的多进程架构" aria-label="Permalink to &quot;浏览器的多进程架构&quot;">​</a></h3><p>Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程</p><ul><li>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li>渲染进程。核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li>GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。</li><li>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li></ul><h3 id="浏览器的渲染流程" tabindex="-1">浏览器的渲染流程 <a class="header-anchor" href="#浏览器的渲染流程" aria-label="Permalink to &quot;浏览器的渲染流程&quot;">​</a></h3><p>按照渲染的时间顺序，渲染流程可分为如下几个子阶段：</p><ul><li>构建DOM树</li><li>样式计算</li><li>布局阶段</li><li>分层</li><li>绘制</li><li>分块</li><li>光栅化和合成</li></ul><p>构建DOM树：DOM是保存在内存中的树状结构，浏览器控制台输入<code>document</code>可以查看，可以通过JavaScript来查询或修改其内容。</p><ul><li>输入内容：HTML文件</li><li>处理过程：经由HTML解析器解析</li><li>输出内容：树状结构的DOM</li></ul><p>样式计算：计算出DOM节点中每个元素的具体样式，分为三步。</p><ul><li>把CSS转换为浏览器能够理解的结构——styleSheets（浏览器控制台输入<code>document.styleSheets</code>可以查看）</li><li>转换样式表中的属性值，使其标准化。CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。例如标准化后2em被解析成了32px，red被解析成了rgb(255,0,0)，bold被解析成了700等值。</li><li>计算出DOM树中每个节点的具体样式。 <ul><li>样式继承：样式计算过程中，会根据DOM节点的继承关系来合理计算节点样式。</li><li>样式层叠：层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。 样式计算阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。</li></ul></li></ul><p>布局阶段：计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。</p><ul><li>创建布局树：DOM树还含有很多不可见的元素，比如head标签，还有使用了display:none属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。 <ul><li>遍历DOM树中的所有可见节点，并把这些节点加到布局中；</li><li>而不可见的节点会被布局树忽略掉，如head标签下面的全部内容，再比如body.p.span这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树</li></ul></li><li>布局计算</li></ul><p>分层：渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。这些图层叠加在一起构成了最终的页面图像。 满足下面两点中任意一点，元素会被提升为单独的一个图层：</p><ul><li>拥有层叠上下文属性的元素会被提升为单独的一层。</li><li>需要剪裁（clip）的地方也会被创建为图层。</li></ul><p>图层绘制：</p><ul><li>渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，</li><li>打开“开发者工具”的“Layers”标签，选择“document”层，可以实际体验下绘制列表，</li></ul><p>栅格化操作</p><ul><li>绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。</li><li>由于图层内容可能很大，而用户可见的视口范围有限，所以合成线程会将图层划分为图块（tile），这些图块的大小通常是256x256或者512x512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。</li><li>所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。</li><li>渲染进程把生成图块的指令发送给GPU，然后在GPU中执行生成图块的位图，并保存在GPU的内存中。</li></ul><p>合成和显示：</p><ul><li>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li><li>浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</li></ul><p>一个完整的渲染流程大致可总结为如下</p><ul><li>渲染进程将HTML内容转换为能够读懂的DOM树结构。</li><li>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令DrawQuad给浏览器进程。</li><li>浏览器进程根据DrawQuad消息生成页面，并显示到显示器上</li></ul><p>参考资料：</p><ul><li><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson05.html#%E6%9E%84%E5%BB%BAdom%E6%A0%91" target="_blank" rel="noreferrer">浏览器工作原理与实践 - 渲染流程</a></li></ul><h3 id="如何实现不同标签页之间通信" tabindex="-1">如何实现不同标签页之间通信 <a class="header-anchor" href="#如何实现不同标签页之间通信" aria-label="Permalink to &quot;如何实现不同标签页之间通信&quot;">​</a></h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。</p><ul><li>使用localStorage的方式，设置同域下共享的localStorage。</li><li>cookie方式，同域下的标签页可共享。</li><li>使用postMessage方法。对于两个不同页面的脚本，只有同源时，这两个脚本才能相互通信。父页面window.open()和子页面postMessage。</li><li>借助服务端或者Service Worker中间层实现</li></ul><p>参考文章：</p><ul><li><a href="https://juejin.cn/post/7270155117705510968?searchId=20231110163050AD6E91402150CA2A6030#heading-3" target="_blank" rel="noreferrer">浏览器跨标签页通信的方式都有什么</a></li></ul><h3 id="pwa解决了web应用哪些问题" tabindex="-1">PWA解决了web应用哪些问题 <a class="header-anchor" href="#pwa解决了web应用哪些问题" aria-label="Permalink to &quot;PWA解决了web应用哪些问题&quot;">​</a></h3><p>PWA，全称是 Progressive Web App，翻译过来就是渐进式网页应用。 它是一套理念，渐进式增强Web的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。基于这套理念之下的技术都可以归类到PWA。</p><p>相对于本地应用，Web页面缺少了什么</p><ul><li>Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</li><li>Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。</li><li>Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。</li></ul><p>PWA对以上Web缺陷提出的解决方案：</p><ul><li>通过引入 Service Worker 来试着解决离线存储和消息推送的问题</li><li>通过引入 manifest.json 来解决一级入口的问题</li></ul>',39),t=[o];function p(s,u,n,d,h,c){return i(),e("div",null,t)}const S=l(r,[["render",p]]);export{m as __pageData,S as default};
