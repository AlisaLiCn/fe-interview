
### npm、yarn与pnpm的区别

**npm V1-V2**  
项目的依赖项在node_modules内部，采用嵌套的结构，这种设计存在的问题：
- 依赖嵌套的层级深，会导致文件路径过长的问题，尤其是在windows系统中。
- 大量重复的包被安装，文件体积超级大，
- 模块实例不能共享，无法共享内部变量，可能导致一些不可预知的bug。

**npm V3 & yarn**  
采用扁平化依赖的管理方式，解决了重复安装和嵌套层级深的问题。但存在其他问题：
- 依赖树结构的不确定性，例如两个不同的依赖项，又分别依赖同一个依赖的不同版本，那么被提升的版本是哪个取决于这两个依赖在package.json中声明的顺序。
- 扁平化算法本身复杂度高，耗时较长。
- 项目中可以非法访问没有声明过的依赖包。

为了解决依赖结构的不确定问题，yarn通过yarn.lock、npm 5.x通过package-lock.json来保证依赖安装后产生确定的node_modules结构。

**pnpm**  
pnpm是全新的包管理器，通过硬链接全局存储，使用符号链接来创建依赖项的嵌套结构。

pnpm特性：
- 节省磁盘空间：使用基于内容寻址的文件系统来存储磁盘上的文件，在全局store里存储依赖，磁盘中只有一个地方写入，真正使用时通过硬链接来引用。
- 安装速度快
- 支持monorepo
- 安全性高：子依赖不会被提升，不会产生幽灵依赖。
- 新版本可以管理node.js版本（从v6.12.0开始）

> 硬链接：硬链接（hard link）是计算机文件系统中的多个文件平等地共享同一个文件存储单元。—— 维基百科

> 符号链接：符号链接（软链接、symbolic link）是一类特殊的文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。 —— 维基百科

> 内容寻址：通过文件内容生成内容地址（通常是通过hash算法生成），再通过内容地址找到文件。

pnpm弊端：
- 由于pnpm创建的node_modules依赖软链接，因此在不支持软链接的环境中，无法使用 pnpm，比如 Electron 应用。
- 因为依赖源文件是安装在store中，调试依赖或patch-package给依赖打补丁也不太方便，可能会影响其他项目。

参考资料：
- [pnpm、yarn、npm功能比较](https://pnpm.io/zh/next/feature-comparison)
- [关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://juejin.cn/post/6932046455733485575)
- [深入浅出 npm & yarn & pnpm 包管理机制](https://juejin.cn/post/7104088592426729480)


