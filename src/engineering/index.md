### 什么是前端工程化
所谓前端工程化，就是在前端开发过程中，采用一系列的技术手段和工具，来提高开发效率、保证代码质量、提高代码复用性、实现自动化流程和促进团队协作等方面的目标，是现代前端开发不可或缺的一部分；


### npm、yarn与pnpm的区别

**npm V1-V2**  
项目的依赖项在node_modules内部，采用嵌套的结构，这种设计存在的问题：
- 依赖嵌套的层级深，会导致文件路径过长的问题，尤其是在windows系统中。
- 大量重复的包被安装，文件体积超级大，
- 模块实例不能共享，无法共享内部变量，可能导致一些不可预知的bug。

**npm V3 & yarn**  
采用扁平化依赖的管理方式，解决了重复安装和嵌套层级深的问题。但存在其他问题：
- 依赖树结构的不确定性，例如两个不同的依赖项，又分别依赖同一个依赖的不同版本，那么被提升的版本是哪个取决于这两个依赖在package.json中声明的顺序。
- 扁平化算法本身复杂度高，耗时较长。
- 项目中可以非法访问没有声明过的依赖包。

为了解决依赖结构的不确定问题，yarn通过yarn.lock、npm 5.x通过package-lock.json来保证依赖安装后产生确定的node_modules结构。

**pnpm**  
pnpm是全新的包管理器，通过硬链接全局存储，使用符号链接来创建依赖项的嵌套结构。

pnpm特性：
- 节省磁盘空间：使用基于内容寻址的文件系统来存储磁盘上的文件，在全局store里存储依赖，磁盘中只有一个地方写入，真正使用时通过硬链接来引用。
- 安装速度快
- 支持monorepo
- 安全性高：子依赖不会被提升，不会产生幽灵依赖。
- 新版本可以管理node.js版本（从v6.12.0开始）

> 硬链接：硬链接（hard link）是计算机文件系统中的多个文件平等地共享同一个文件存储单元。—— 维基百科

> 符号链接：符号链接（软链接、symbolic link）是一类特殊的文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。 —— 维基百科

> 内容寻址：通过文件内容生成内容地址（通常是通过hash算法生成），再通过内容地址找到文件。

pnpm弊端：
- 由于pnpm创建的node_modules依赖软链接，因此在不支持软链接的环境中，无法使用 pnpm，比如 Electron 应用。
- 因为依赖源文件是安装在store中，调试依赖或patch-package给依赖打补丁也不太方便，可能会影响其他项目。

参考资料：
- [pnpm、yarn、npm功能比较](https://pnpm.io/zh/next/feature-comparison)
- [关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://juejin.cn/post/6932046455733485575)
- [深入浅出 npm & yarn & pnpm 包管理机制](https://juejin.cn/post/7104088592426729480)


### 如何⽤webpack来优化前端性能
⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。
- 压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件，利⽤ cssnano（css-loader?minimize）来压缩css。
- 利⽤CDN加速: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于output参数和各loader的publicPath参数来修改资源路径。 
- Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 --optimize-minimize 来实现 
- Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存 
- 提取公共第三⽅库: SplitChunksPlugin插件来进⾏公共模块抽取, 利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码

### 如何提高webpack构建速度
1.多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码
2.通过 externals 配置来提取常⽤库
3.利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。
4.使⽤ Happypack 实现多线程加速编译
5.使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度
6.使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码

### 设计实现前端埋点SDK
**埋点监控的作用**  
- 数据监控：监控用户行为
- 性能监控
- 异常监控

**埋点SDK实现**  
需要具备的功能
- 发送数据：一般使用gif图片进行数据传输。
- 上报性能数据
- 捕获报错信息

参考资料：
- [设计实现一个埋点监控SDK](https://juejin.cn/post/7085679511290773534)
- [前端监控和前端埋点方案设计](https://juejin.cn/post/6844903650603565063)