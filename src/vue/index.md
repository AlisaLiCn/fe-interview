
### Vue的基本原理
当一个Vue实例创建时，Vue会遍历data中的属性，用Object.defineProperty（vue3.0使用proxy）将它们转为getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

### 双向数据绑定的原理
Vue.js是采用数据劫持结合发布-订阅模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：
1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。
2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。
3. Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:①在自身实例化时往属性订阅器(dep)里面添加自己②自身必须有一个update()方法③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。

### MVVM MVC MVP 的区别
MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。

在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时， 可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。

1. MVC
MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。 其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据， 以及对相应数据的操作。并且 View 和 Model 应用了观察者模式， 当 Model 层发生改变的时候它会通知有关 View 层更新页面。
Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。

2. MVVM
MVVM 分为 Model、View、ViewModel： Model 代表数据模型，数据和业务逻辑都在 Model 层中定义； View 代表 UI 视图，负责数据的展示； ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的， Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中 的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。 这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作 DOM。

3. MVP
MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起， 当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的 Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中， View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦， Presenter 还包含了其他的响应逻辑。

### Vue模板编译原理
vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这个转化的过程，就称为模板编译。模板编译又分三个阶段，解析parse，优化optimize， 生成generate，最终生成可执行函数render。
- 解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。 
- 优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。 
- 生成阶段：将最终的AST转化为render函数字符串。

### 对Vue组件化的理解
1.组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；
2.组件化开发能大幅提高应用开发效率、测试性、复用性等； 
3.组件使用按分类有：页面组件、业务组件、通用组件； 
4.vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue； 
5.vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；
6.合理的划分组件，有助于提升应用性能；组件应该是高内聚、低耦合的； 
7.遵循单向数据流的原则。

### 对Vue设计原则的理解
1. 渐进式JavaScript框架：与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。 
2. 易用性：vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。 
3. 灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。 
4. 高效性：超快的虚拟DOM和diff算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。


### 说说Vue的生命周期
Vue实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载等⼀系列过程，称这是Vue的⽣命周期。

1. beforeCreate（创建前）：数据观测和初始化事件还未开始，此时data的响应式追踪、event/watcher都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。
2. created（创建后）：实例创建完成，实例上配置的options包括data、computed、watch、methods等都配置完成，但是此时渲染得节点还未挂载到DOM，所以不能访问到$el属性。 
3. beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。 
4. mounted（挂载后）：在el被新创建的vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行 ajax交互。
5. beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实DOM还没有被渲染。 
6. updated（更新后） ：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。此时DOM已经根据响应式数据的变化更新了。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 
7. beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。 
8. destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。
另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行activated钩子函数。


### created和mounted区别
- created: 在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 
- mounted: 在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。mounted不保证所有的子组件也都一起被挂载。如果希望等到整个视图都渲染完毕，可以在mounted内部使用 vm.$nextTick。

### slot的作用及原理
slot 又名插槽，是 Vue 的内容分发机制，组件内部的模板引擎使用 slot 元素作为承载分发内容的出口。插槽 slot 是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot 又分三类，默认插槽、具名插槽和作用域插槽。

- 默认插槽：又名匿名插槽，当 slot 没有指定 name 属性值的时候一个默认显示插槽，一个组件内只有一个匿名插槽。
- 具名插槽：带有具体名字的插槽，也就是带有 name 属性的 slot，一个组件可以出现多个具名插槽。
- 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

实现原理：当子组件 vm 实例化时，获取到父组件传入的 slot 标签的内容，存放在 vm.$slot 中，默认插槽为 vm.$slot.default，具名插槽为 vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到 slot 标签，使用$slot 中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。

### $nextTick原理及作用
原理：Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。nextTick 的核心是利用了如 Promise、 MutationObserver、 setImmediate、setTimeout的原生JavaScript方法来模拟对应的微/宏任务的实现，本质是为了利用JavaScript的这些异步回调任务队列来实现Vue。nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对DOM更新数据时机的后续逻辑处理。

nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶
- 如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，异步可以减少一些无用渲染。
- 同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要。

用到nextTick的场景：
- 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。
- 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。


### Vue子组件和父组件执行顺序
加载渲染过程： 
1. 父组件 beforeCreate 
2. 父组件 created 
3. 父组件 beforeMount
4. 子组件 beforeCreate 
5. 子组件 created 
6. 子组件 beforeMount 
7. 子组件 mounted 
8. 父组件 mounted

更新过程： 
1. 父组件 beforeUpdate 
2. 子组件 beforeUpdate 
3. 子组件 updated 
4. 父组件 updated

销毁过程： 
1. 父组件 beforeDestroy
2. 子组件 beforeDestroy 
3. 子组件 destroyed 
4. 父组件 destoryed

### 一般在哪个生命周期请求异步数据
我们可以在钩子函数created、beforeMount、mounted中进行调用， 因为在这三个钩子函数中，data已经创建，可以将服务端端返回的数据进行赋值。 

推荐在created钩子函数中调用异步请求，因为在created钩子函数中调用异步请求有以下优点： 
- 能更快获取到服务端数据，减少页面加载时间，用户体验更好； 
- SSR不支持beforeMount、mounted钩子函数，放在created中有助于一致性。

### keep-alive中的生命周期哪些
keep-alive是Vue提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。

如果为一个组件包裹了keep-alive，那么它会多出两个生命周期： deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 
- 当组件被换掉时，会被缓存到内存中、触发 deactivated生命周期； 
- 当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。


### 子组件可以直接改变父组件的数据吗
子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。

Vue 提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

### 对React和Vue的理解并比较他们的异同
相似之处：
- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；
- 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；
- 都使用了Virtual DOM（虚拟 DOM）提高重绘性能；
- 都有 props 的概念，允许组件间的数据传递；
- 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。

不同之处：
- 数据流：Vue 默认支持数据双向绑定，而 React 一直提倡单向数据流。
- 虚拟DOM：Vue2.x 开始引入"Virtual DOM"，消除了和 React 在这方面的差异， 但是在具体的细节还是有各自的特点。
  - Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。
  - 对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制，但Vue将此视为默认的优化。
- 组件化：
  - Vue 鼓励写近似常规 HTML 的模板。写起来很接近标准 HTML 元素，只 是多了一些属性。React 推荐你所有的模板通用 JavaScript 的语法扩展——JSX书写。 
  - 具体来讲：React 中 render 函数是支持闭包特性的，所以 import 的 组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。
- 监听数据变化的实现原理不同：Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。React 默认是通过比较引用的方式进行的 ， 如果不优化 （PureComponent/shouldComponentUpdate）可能导致大量不必要的 vDOM 的重新渲染。这是因为 Vue 使用的是可变数据，而 React 更强调数据的不可变。
- 高阶组件：
  - react 可以通过高阶组件（HOC）来扩展，而 Vue 需要通过 mixins 来扩展。
  - 高阶组件就是高阶函数，而 React 的组件本身就是纯粹的函数，所以高阶函数对 React 来说易如反掌。相反 Vue.js 使用 HTML 模板创建视图组件，这时模板无法有效的编译，因此 Vue 不能采用 HOC 来实现。
- 构建工具：两者都有自己的构建工具：React ==> Create React APP，Vue ==> vue-cli。
- 跨平台：React ==> React Native，Vue ==> Weex。

### Vue的优点
- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；
- 简单易学：国人开发，中文文档，不存在语言障碍，易于理解和学习；
- 双向数据绑定：保留了angular的特点，在数据操作方面更为简单；
- 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；
- 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
- 虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；
- 运行速度更快：相比较于react而言，同样是操作虚拟dom，就性能而言， vue存在很大的优势。

### Vue3的新变化
1. 数据响应式系统升级
- Vue2中响应式系统的核心是Object.defineProperty，需要进行深度遍历所有属性，给每个属性添加getter和setter，且在初始化时就需要全部处理。
- Vue3中使用Proxy重写响应式系统，只有在访问属性时才去拦截。消除了Vue2中数据响应式变化监测的几个限制：
  - 可以监听动态新增的属性
  - 可以监听删除的属性
  - 可以监听数组的索引和length值

2. 编译阶段优化

diff算法优化：
- vue2中通过标记静态**根**节点，优化diff的过程，diff时会跳过静态根节点
- vue3中标记和提升所有的静态节点，diff时只需要对比动态内容
  * 引入Fragments，模板中不需要创建唯一根节点
  * 静态提升，diff时跳过静态节点
  * patchFlag进行节点标记，diff时只更新动态的内容
  * 缓存事件处理函数，减少不必要的更新=

静态提升：
对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。
这样免去了重复的创建节点，大型应用会受益于这个改动，优化运行时的内存占用。

动态标记：
Vue3在diff算法相比2增加了动态标记，作用是为了在发生变化的地方加一个flag标记，下次发生变化时直接找该位置进行比较。提升性能。作为动态标记的类型有：
- Text 动态的文本节点
- CLASS 动态的class
- STYLE 动态的style

3. 增加Composition API
- 代码的逻辑组织、复用更灵活
- 避免了Vue2中Mixin写法导致的代码来源不清晰
- setup作为入口
- 全新的响应式API及生命周期钩子，ref()、reactive()等
- 可以与Vue2的option API一起使用
- Vue3模块可以和其他框架搭配使用

4. 更好的typescript支持
- vue2基于flow
- Vue3是基于ts编写，可以享受自动的类型提示

5. 源码体积方面
- 移除了一些不常用API，例如：inline-template、filter等（filter可以通过method或computed实现）
- Vue3中，全局API通过具名导出方式进行访问，对tree-shaking支持更好，tree-shaking依赖ES Module，在打包阶段过滤掉没有引用的模块，让打包体积更小。

6. 其他变化
- 支持fragments：vue组件支持多个根节点。
- 新增teleport内置组件：模板的传送门，它可以将一个组件内部的一部分模板“传送”到该组件的DOM结构外层的位置去。例如modal、toast之类的应用场景。

整体来说：
* 性能提升
* 速度更快
* 体积更小
* 更易维护
* 更接近原生
* 更容易使用

参考资料：
- [深入响应式系统](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)
- [Vue3迁移指南-非兼容性改变](https://v3-migration.vuejs.org/zh/breaking-changes/)