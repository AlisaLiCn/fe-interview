<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Front End Interview | Front End Interview</title>
    <meta name="description" content="A collection of Front-End interview questions and study materials">
    <link rel="preload stylesheet" href="/fe-interview/assets/style.903ed23e.css" as="style">
    
    <script type="module" src="/fe-interview/assets/app.ff9b0c1c.js"></script>
    <link rel="preload" href="/fe-interview/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/fe-interview/assets/chunks/framework.d290a28e.js">
    <link rel="modulepreload" href="/fe-interview/assets/chunks/theme.fc18daed.js">
    <link rel="modulepreload" href="/fe-interview/assets/javascript_index.md.792b6076.lean.js">
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-255ec12d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-ae3e3f51></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-ae3e3f51> Skip to content </a><!--]--><!----><header class="VPNav" data-v-255ec12d data-v-7e5bc4a5><div class="VPNavBar has-sidebar" data-v-7e5bc4a5 data-v-faa4ef78><div class="container" data-v-faa4ef78><div class="title" data-v-faa4ef78><div class="VPNavBarTitle has-sidebar" data-v-faa4ef78 data-v-8bbac535><a class="title" href="/fe-interview/" data-v-8bbac535><!--[--><!--]--><!----><!--[-->Front End Interview<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-faa4ef78><div class="curtain" data-v-faa4ef78></div><div class="content-body" data-v-faa4ef78><!--[--><!--]--><div class="VPNavBarSearch search" style="--vp-meta-key:&#39;Meta&#39;;" data-v-faa4ef78><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-faa4ef78 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> Basics <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link active" href="/fe-interview/javascript/" data-v-2f2cfafc><!--[-->JavaScript<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-interview/html/" data-v-2f2cfafc><!--[-->HTML<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-interview/css/" data-v-2f2cfafc><!--[-->CSS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-interview/typescript/" data-v-2f2cfafc><!--[-->TypeScript<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> Framework <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-interview/vue/" data-v-2f2cfafc><!--[-->Vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-interview/react/" data-v-2f2cfafc><!--[-->React<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/fe-interview/engineering/" tabindex="0" data-v-7f418b0f data-v-5e623618><!--[-->Engineering<!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-faa4ef78 data-v-f6a63727><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-f6a63727 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-faa4ef78 data-v-40855f84 data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-764effdf><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-764effdf><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-faa4ef78 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav reached-top" data-v-255ec12d data-v-5cfd5582><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5cfd5582><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-5cfd5582><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-5cfd5582>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5cfd5582 data-v-d5bb9d56><button data-v-d5bb9d56>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-255ec12d data-v-845b8fc6><div class="curtain" data-v-845b8fc6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-845b8fc6><span class="visually-hidden" id="sidebar-aria-label" data-v-845b8fc6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-845b8fc6><section class="VPSidebarItem level-0" data-v-845b8fc6 data-v-4fbabd82><div class="item" role="button" tabindex="0" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><h2 class="text" data-v-4fbabd82>javascript基础</h2><!----></div><div class="items" data-v-4fbabd82><!--[--><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#javascript的数据类型及它们的区别" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>JavaScript的数据类型及它们的区别</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#检测数据类型的方式有哪些" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>检测数据类型的方式有哪些</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#null和undefined区别" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>null和undefined区别</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#intanceof操作符的实现原理及代码实现" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>intanceof操作符的实现原理及代码实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#对原型及原型链的理解" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>对原型及原型链的理解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#创建对象的方式有哪些" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>创建对象的方式有哪些</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#对象继承的方式有哪些" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>对象继承的方式有哪些</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#对作用域及作用域链的理解" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>对作用域及作用域链的理解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#对this对象的理解" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>对this对象的理解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#箭头函数的this指向哪里" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>箭头函数的this指向哪里</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#call-apply-bind的区别" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>call apply bind的区别</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#for-in-和-for-of-的区别" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>for...in和for...of的区别</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#异步编程的实现方式" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>异步编程的实现方式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#对promise的理解" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>对Promise的理解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#对async-await的理解" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>对async/await的理解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#async-await-对比-promise-的优势" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>async/await 对比 Promise 的优势</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#es-module与commonjs模块有什么异同" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>ES Module与CommonJS模块有什么异同</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/#哪些情况会导致内存泄漏" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>哪些情况会导致内存泄漏</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-845b8fc6><section class="VPSidebarItem level-0" data-v-845b8fc6 data-v-4fbabd82><div class="item" role="button" tabindex="0" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><h2 class="text" data-v-4fbabd82>正则表达式</h2><!----></div><div class="items" data-v-4fbabd82><!--[--><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/regexp/#将数字转换为千分位分隔形式" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>将数字转换为千分位分隔形式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/regexp/#实现一个获取URL中参数的queryString方法" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>实现一个获取URL中参数的queryString方法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/regexp/#写一个获取颜色的正则表达式" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>写一个获取颜色的正则表达式</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-845b8fc6><section class="VPSidebarItem level-0" data-v-845b8fc6 data-v-4fbabd82><div class="item" role="button" tabindex="0" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><h2 class="text" data-v-4fbabd82>性能优化</h2><!----></div><div class="items" data-v-4fbabd82><!--[--><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/optimize/#懒加载的概念" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>懒加载的概念</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/optimize/#懒加载的实现原理" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>懒加载的实现原理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-4fbabd82 data-v-4fbabd82><div class="item" data-v-4fbabd82><div class="indicator" data-v-4fbabd82></div><a class="VPLink link link" href="/fe-interview/javascript/optimize/#对防抖和节流的理解" data-v-4fbabd82><!--[--><p class="text" data-v-4fbabd82>对防抖和节流的理解</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-255ec12d data-v-3107c4ee><div class="VPDoc has-sidebar has-aside" data-v-3107c4ee data-v-6b87e69f><!--[--><!--]--><div class="container" data-v-6b87e69f><div class="aside" data-v-6b87e69f><div class="aside-curtain" data-v-6b87e69f></div><div class="aside-container" data-v-6b87e69f><div class="aside-content" data-v-6b87e69f><div class="VPDocAside" data-v-6b87e69f data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-3f215769 data-v-ff0f39c8><div class="content" data-v-ff0f39c8><div class="outline-marker" data-v-ff0f39c8></div><div class="outline-title" data-v-ff0f39c8>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-ff0f39c8><span class="visually-hidden" id="doc-outline-aria-label" data-v-ff0f39c8> Table of Contents for current page </span><ul class="root" data-v-ff0f39c8 data-v-b0ff2abe><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-6b87e69f><div class="content-container" data-v-6b87e69f><!--[--><!--]--><!----><main class="main" data-v-6b87e69f><div style="position:relative;" class="vp-doc _fe-interview_javascript_index" data-v-6b87e69f><div><h3 id="javascript的数据类型及它们的区别" tabindex="-1">JavaScript的数据类型及它们的区别 <a class="header-anchor" href="#javascript的数据类型及它们的区别" aria-label="Permalink to &quot;JavaScript的数据类型及它们的区别&quot;">​</a></h3><p>参考题解：</p><p>JavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、 Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数， 使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围</li></ul><p>这些数据可以分为基本数据类型和引用数据类型：</p><ul><li>栈：基本数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于存储位置的不同：</p><ul><li>基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，</p><p>在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="检测数据类型的方式有哪些" tabindex="-1">检测数据类型的方式有哪些 <a class="header-anchor" href="#检测数据类型的方式有哪些" aria-label="Permalink to &quot;检测数据类型的方式有哪些&quot;">​</a></h3><p>1.typeof</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// number</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// boolean</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">str</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// string</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> []) </span><span style="color:#676E95;font-style:italic;">// object</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// object</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){}</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// function</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">null</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// object</span></span></code></pre></div><p>其中数组、对象、null 都会被判断为 object，其他判断都正确。</p><p>2.instanceof instanceof 可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Number</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#FF9CAC;">true</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Boolean</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">str</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">String</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">([] </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Array</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{}</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){}</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Function</span><span style="color:#BABED8;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><p>instanceof 只能正确判断引用数据类型，而不能判断基本数据类型。 instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</p><p>3.constructor constructor 有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。 需要注意，如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型了：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#BABED8;">()</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Array) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Fn</span><span style="color:#89DDFF;">(){}</span></span>
<span class="line"><span style="color:#FFCB6B;">Fn</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#BABED8;">()</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> f </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Fn</span><span style="color:#BABED8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Fn) </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Array) </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><p>4.Object.prototype.toString.call() Object.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">toString</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;">)) </span><span style="color:#676E95;font-style:italic;">// [object Number]</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(</span><span style="color:#FF9CAC;">true</span><span style="color:#BABED8;">)) </span><span style="color:#676E95;font-style:italic;">// [object Boolean]</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">str</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)) </span><span style="color:#676E95;font-style:italic;">// [object String]</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">([])) </span><span style="color:#676E95;font-style:italic;">// [object Array]</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{}</span><span style="color:#BABED8;">)) </span><span style="color:#676E95;font-style:italic;">// [object Object]</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){}</span><span style="color:#BABED8;">)) </span><span style="color:#676E95;font-style:italic;">// [object Function]</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">undefined</span><span style="color:#BABED8;">)) </span><span style="color:#676E95;font-style:italic;">// [object Undefined]</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">null</span><span style="color:#BABED8;">)) </span><span style="color:#676E95;font-style:italic;">// [object Null]</span></span></code></pre></div><p>与obj.toString()不同，toString 是 Object 的原型方法，而 Array、function 等类型作为 Object 的实例，都重写了 toString 方法。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString() 不能得到其对象类型，只能将 obj 转换为字符串类型；</p><p>因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p><h3 id="null和undefined区别" tabindex="-1">null和undefined区别 <a class="header-anchor" href="#null和undefined区别" aria-label="Permalink to &quot;null和undefined区别&quot;">​</a></h3><p>Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="intanceof操作符的实现原理及代码实现" tabindex="-1">intanceof操作符的实现原理及代码实现 <a class="header-anchor" href="#intanceof操作符的实现原理及代码实现" aria-label="Permalink to &quot;intanceof操作符的实现原理及代码实现&quot;">​</a></h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><p>实现1：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">myInstanceof</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">left</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">right</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 获取对象的原型</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">proto</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPrototypeOf</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">left</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 获取构造函数的prototype属性</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">right</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;">(</span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#BABED8;">proto</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">proto</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">prototype</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 如果没有找到，继续从其原型上找，Object.getPrototypeOf用来获取指定对象的原型</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">proto</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPrototypeOf</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">proto</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>实现2：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">myInstanceof</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">left</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">right</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">proto</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">left</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">__proto__</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">proto</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">proto</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">right</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">proto</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">proto</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">__proto__</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="对原型及原型链的理解" tabindex="-1">对原型及原型链的理解 <a class="header-anchor" href="#对原型及原型链的理解" aria-label="Permalink to &quot;对原型及原型链的理解&quot;">​</a></h3><p>在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。 一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。 ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以新建的对象时能够使用 toString() 等方法。</p><p>特点：JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p><p><strong>原型链的终点：</strong> 由于 Object 是构造函数，原型链终点 Object.prototype.<strong>proto</strong>， 而 Object.prototype.<strong>proto</strong>=== null // true，所以，原型链的终点是 null。原型链上的所有原型都是对象，所有的对象最终都是由 Object 构造的，而 Object.prototype 的下一级是 Object.prototype.<strong>proto</strong>。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">__proto__) </span><span style="color:#676E95;font-style:italic;">// null</span></span></code></pre></div><h3 id="创建对象的方式有哪些" tabindex="-1">创建对象的方式有哪些 <a class="header-anchor" href="#创建对象的方式有哪些" aria-label="Permalink to &quot;创建对象的方式有哪些&quot;">​</a></h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><ol><li>第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</li><li>第二种是构造函数模式。js 中每一个函数都可以作为构造函数， 只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。 执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象， 最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。 构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</li><li>第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</li><li>第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的 解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</li><li>第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</li><li>第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型， 在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</li></ol><h3 id="对象继承的方式有哪些" tabindex="-1">对象继承的方式有哪些 <a class="header-anchor" href="#对象继承的方式有哪些" aria-label="Permalink to &quot;对象继承的方式有哪些&quot;">​</a></h3><ol><li>第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享， 容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传 递参数。</li><li>第二种方式是使用借用构造函数的方式，这种方式是通过在子 类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不 能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函 数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</li><li>第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属 性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我 们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</li><li>第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象， 然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</li><li>第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本， 然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这 个对象不是自定义类型时。缺点是没有办法实现函数的复用。</li><li>第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式 组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</li></ol><h3 id="对作用域及作用域链的理解" tabindex="-1">对作用域及作用域链的理解 <a class="header-anchor" href="#对作用域及作用域链的理解" aria-label="Permalink to &quot;对作用域及作用域链的理解&quot;">​</a></h3><ol><li>全局作用域和函数作用域</li></ol><p>全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有 window 对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>函数作用域</p><ul><li>函数作用域声明在函数内部的变量，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><ol start="2"><li>块级作用域</li></ol><ul><li>使用 ES6 中新增的 let 和 const 指令可以声明块级作用域</li><li>块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代 码片段）</li><li>let 和 const 声明的变量不会有变量提升，也不可以重复声明 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><ol start="3"><li>作用域链 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。 如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止， 这一层层的关系就是作用域链。</li></ol><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</p><p>作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。 作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="对this对象的理解" tabindex="-1">对this对象的理解 <a class="header-anchor" href="#对this对象的理解" aria-label="Permalink to &quot;对this对象的理解&quot;">​</a></h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><p>第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p><p>第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时， this 指向这个对象。</p><p>第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p><p>第四种是apply 、 call和bind调用模式，这三个方法都可以显示地指定调用函数的 this 指向。其中 apply 方法接收两个参数： 一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数， 第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。 也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="箭头函数的this指向哪里" tabindex="-1">箭头函数的this指向哪里 <a class="header-anchor" href="#箭头函数的this指向哪里" aria-label="Permalink to &quot;箭头函数的this指向哪里&quot;">​</a></h3><p>箭头函数不同于传统 JavaScript 中的函数，箭头函数并没有属于⾃⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值， 并且由于没有属于⾃⼰的 this，所以是不会被 new 调⽤的，这个所谓的 this 也不会被改变。</p><p>用babel理解一下箭头函数：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">// ES6</span></span>
<span class="line"><span style="color:#babed8;">const obj = {</span></span>
<span class="line"><span style="color:#babed8;">  getArrow() {</span></span>
<span class="line"><span style="color:#babed8;">    return () =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">      console.log(this === obj)</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">  }</span></span>
<span class="line"><span style="color:#babed8;">}</span></span></code></pre></div><p>转化后：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">// ES5，由babel转译</span></span>
<span class="line"><span style="color:#babed8;">var obj = {</span></span>
<span class="line"><span style="color:#babed8;">  getArrow: function getArrow() {</span></span>
<span class="line"><span style="color:#babed8;">    var _this = this</span></span>
<span class="line"><span style="color:#babed8;">    return function() {</span></span>
<span class="line"><span style="color:#babed8;">      console.log(_this === obj)</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">  }</span></span>
<span class="line"><span style="color:#babed8;">}</span></span></code></pre></div><h3 id="call-apply-bind的区别" tabindex="-1">call apply bind的区别 <a class="header-anchor" href="#call-apply-bind的区别" aria-label="Permalink to &quot;call apply bind的区别&quot;">​</a></h3><p>call、apply的作用一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向， 第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><p>bind</p><ul><li>bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</li><li>返回值：返回一个原函数的拷贝，并拥有指定的this值和初始参数。</li></ul><p><strong>区别</strong></p><ul><li>call和apply立即执行，bind不立即执行</li><li>call和apply接收参数方式不同</li></ul><p><strong>应用场景</strong> call和apply：</p><ul><li>数据类型判断：Object.prototype.toString.call()几乎可以判断所有类型的数据</li><li>继承：借用构造函数，在子类型中调用父类型的函数</li></ul><h3 id="for-in-和-for-of-的区别" tabindex="-1">for...in 和 for...of 的区别 <a class="header-anchor" href="#for-in-和-for-of-的区别" aria-label="Permalink to &quot;for...in 和 for...of 的区别&quot;">​</a></h3><p>for...of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口的数据结构（可迭代对象，数组、对象等）并且返回各项的值，和 ES3 中的 for...in 的区别如下：</p><ul><li>for...in 获取的是对象的键名（Symbol除外），for...of 遍历获取的是对象的键值；</li><li>for...in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for...of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for...in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for...of 只返回数组的下标对应的属性值；</li></ul><p>总结：for...in 循环主要是为了遍历对象而生，不适用于遍历数组； for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以 及 Generator 对象。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;">(</span><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> key </span><span style="color:#89DDFF;">in</span><span style="color:#BABED8;"> obj)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//statements</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;"> (variable </span><span style="color:#89DDFF;">of</span><span style="color:#BABED8;"> iterable) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//statements</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="异步编程的实现方式" tabindex="-1">异步编程的实现方式 <a class="header-anchor" href="#异步编程的实现方式" aria-label="Permalink to &quot;异步编程的实现方式&quot;">​</a></h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li>回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li>Promise的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用， 可能会造成代码的语义不够明确。</li><li>generator的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li>async 函数的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="对promise的理解" tabindex="-1">对Promise的理解 <a class="header-anchor" href="#对promise的理解" aria-label="Permalink to &quot;对Promise的理解&quot;">​</a></h3><p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调， 它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的API， 各种异步操作都可以用同样的方法进行处理。</p><ol><li>Promise 的实例有三个状态</li></ol><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝） 当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了，状态就变成了 Resolved、没有完成失败了就变成了 Rejected。</li></ul><ol start="2"><li>Promise 的实例有两个过程</li></ol><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝） 注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</li></ul><p><strong>Promise的特点</strong></p><ul><li>对象的状态不受外界影响。promise 对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是 promise 这个名字的由来——“承诺”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled，从 pending 变为 rejected。这时就称为 resolved（已定型）。如果改变已经发生了，你再对 promise 对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p>Promise 的缺点： 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始 还是即将完成）</p><p>总结： Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。 一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变， 就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在 异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原 型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的 改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的 末尾执行。</p><p>注意：在构造 Promise 的时候，构造函数内部的代码是立即执行的</p><h3 id="对async-await的理解" tabindex="-1">对async await的理解 <a class="header-anchor" href="#对async-await的理解" aria-label="Permalink to &quot;对async await的理解&quot;">​</a></h3><p>async/await 其实是 Generator 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。 从字面上来看， async 是“异步”的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">async</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">testAsync</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello, world</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">testAsync</span><span style="color:#BABED8;">()</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(result)</span></span></code></pre></div><p>执行上述代码，可以看出，async 函数（包含 函数语句、函数表达式、Lambda 表达式）返回的事一个 Promise 对象， 如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">async</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">testAsync</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello, world</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">testAsync</span><span style="color:#BABED8;">()</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(result)</span></span>
<span class="line"><span style="color:#BABED8;">result</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#BABED8;">(</span><span style="color:#BABED8;font-style:italic;">data</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">data</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// hello, world</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre></div><p>如果 async 函数没有返回值，它会返回 Promise.resolve(undefined)。</p><p>联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且， 绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p>注意：Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="async-await-对比-promise-的优势" tabindex="-1">async await 对比 Promise 的优势 <a class="header-anchor" href="#async-await-对比-promise-的优势" aria-label="Permalink to &quot;async await 对比 Promise 的优势&quot;">​</a></h3><ul><li>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担。</li><li>Promise 传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅。</li><li>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余。</li><li>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul><h3 id="es-module与commonjs模块有什么异同" tabindex="-1">ES Module与CommonJS模块有什么异同 <a class="header-anchor" href="#es-module与commonjs模块有什么异同" aria-label="Permalink to &quot;ES Module与CommonJS模块有什么异同&quot;">​</a></h3><p>ES Module 和 CommonJS 模块的区别：</p><ul><li>CommonJs可以动态加载语句，代码发生在运行时；ES Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时。</li><li>CommonJs导出值是对模块的浅拷贝，可以修改导出的值，会引起变量污染；ES Module是对模块的引用，只读只存，不能修改其值，也就是指针指向不能变，类似 const，但可以改变变量内部指针指向，</li><li>可以对 commonJS 重新赋值（改变指针指向），但是对 ES Module 赋值会编译报错。</li></ul><p>ES Module 和 CommonJS 模块的共同点： CommonJS 和 ES Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</p><p><strong>ES Module</strong></p><p>ES6模块加载规范</p><p>特点：编译时加载（静态加载），而不是CommonJS那种运行时加载，效率更高。</p><ul><li>ES Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时</li><li>ES Module混合导出，单个导出，默认导出，完全互不影响</li><li>ES Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改</li></ul><p><strong>CommonJS规范</strong></p><p>nodejs的模块系统，参照CommonJS规范实现。</p><ul><li><code>const fs = require(&#39;fs&#39;)</code>引入模块</li><li><code>module.exports = {}</code> 暴露模块</li></ul><h3 id="哪些情况会导致内存泄漏" tabindex="-1">哪些情况会导致内存泄漏 <a class="header-anchor" href="#哪些情况会导致内存泄漏" aria-label="Permalink to &quot;哪些情况会导致内存泄漏&quot;">​</a></h3><p>以下四种情况会造成内存的泄漏：</p><ul><li>意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul></div></div></main><footer class="VPDocFooter" data-v-6b87e69f data-v-37656e44><!--[--><!--]--><!----><nav class="prev-next" data-v-37656e44><div class="pager" data-v-37656e44><!----></div><div class="pager" data-v-37656e44><a class="pager-link next" href="/fe-interview/javascript/#javascript的数据类型及它们的区别" data-v-37656e44><span class="desc" data-v-37656e44>Next page</span><span class="title" data-v-37656e44>JavaScript的数据类型及它们的区别</span></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-255ec12d data-v-e03eb2e1><div class="container" data-v-e03eb2e1><!----><p class="copyright" data-v-e03eb2e1>Copyright © 2022-2023 <a href="https://github.com/alisalicn" target="_blank">Alisa Li</a></p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"engineering_index.md\":\"c66cad72\",\"html_index.md\":\"a6a1eed4\",\"index.md\":\"70b90e7c\",\"css_index.md\":\"28e7527d\",\"javascript_index.md\":\"792b6076\",\"javascript_optimize_index.md\":\"d7ac9897\",\"javascript_regexp_index.md\":\"8e265dd9\",\"react_index.md\":\"1933853b\",\"typescript_index.md\":\"0bf6198a\",\"vue_index.md\":\"1022f76c\",\"vue_vue-router_index.md\":\"4494f5a9\",\"vue_vuex_index.md\":\"43866181\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Front End Interview\",\"description\":\"A collection of Front-End interview questions and study materials\",\"base\":\"/fe-interview/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Basics\",\"activeMatch\":\"^/(html|css|javascript|typescript)/\",\"items\":[{\"text\":\"JavaScript\",\"link\":\"/javascript/\"},{\"text\":\"HTML\",\"link\":\"/html/\"},{\"text\":\"CSS\",\"link\":\"/css/\"},{\"text\":\"TypeScript\",\"link\":\"/typescript/\"}]},{\"text\":\"Framework\",\"activeMatch\":\"^/(vue|react)/\",\"items\":[{\"text\":\"Vue\",\"link\":\"/vue/\"},{\"text\":\"React\",\"link\":\"/react/\"}]},{\"text\":\"Engineering\",\"activeMatch\":\"^/engineering/\",\"link\":\"/engineering/\"}],\"sidebar\":{\"javascript\":[{\"text\":\"javascript基础\",\"items\":[{\"text\":\"JavaScript的数据类型及它们的区别\",\"link\":\"/javascript/#javascript的数据类型及它们的区别\"},{\"text\":\"检测数据类型的方式有哪些\",\"link\":\"/javascript/#检测数据类型的方式有哪些\"},{\"text\":\"null和undefined区别\",\"link\":\"/javascript/#null和undefined区别\"},{\"text\":\"intanceof操作符的实现原理及代码实现\",\"link\":\"/javascript/#intanceof操作符的实现原理及代码实现\"},{\"text\":\"对原型及原型链的理解\",\"link\":\"/javascript/#对原型及原型链的理解\"},{\"text\":\"创建对象的方式有哪些\",\"link\":\"/javascript/#创建对象的方式有哪些\"},{\"text\":\"对象继承的方式有哪些\",\"link\":\"/javascript/#对象继承的方式有哪些\"},{\"text\":\"对作用域及作用域链的理解\",\"link\":\"/javascript/#对作用域及作用域链的理解\"},{\"text\":\"对this对象的理解\",\"link\":\"/javascript/#对this对象的理解\"},{\"text\":\"箭头函数的this指向哪里\",\"link\":\"/javascript/#箭头函数的this指向哪里\"},{\"text\":\"call apply bind的区别\",\"link\":\"/javascript/#call-apply-bind的区别\"},{\"text\":\"for...in和for...of的区别\",\"link\":\"/javascript/#for-in-和-for-of-的区别\"},{\"text\":\"异步编程的实现方式\",\"link\":\"/javascript/#异步编程的实现方式\"},{\"text\":\"对Promise的理解\",\"link\":\"/javascript/#对promise的理解\"},{\"text\":\"对async/await的理解\",\"link\":\"/javascript/#对async-await的理解\"},{\"text\":\"async/await 对比 Promise 的优势\",\"link\":\"/javascript/#async-await-对比-promise-的优势\"},{\"text\":\"ES Module与CommonJS模块有什么异同\",\"link\":\"/javascript/#es-module与commonjs模块有什么异同\"},{\"text\":\"哪些情况会导致内存泄漏\",\"link\":\"/javascript/#哪些情况会导致内存泄漏\"}]},{\"text\":\"正则表达式\",\"items\":[{\"text\":\"将数字转换为千分位分隔形式\",\"link\":\"/javascript/regexp/#将数字转换为千分位分隔形式\"},{\"text\":\"实现一个获取URL中参数的queryString方法\",\"link\":\"/javascript/regexp/#实现一个获取URL中参数的queryString方法\"},{\"text\":\"写一个获取颜色的正则表达式\",\"link\":\"/javascript/regexp/#写一个获取颜色的正则表达式\"}]},{\"text\":\"性能优化\",\"items\":[{\"text\":\"懒加载的概念\",\"link\":\"/javascript/optimize/#懒加载的概念\"},{\"text\":\"懒加载的实现原理\",\"link\":\"/javascript/optimize/#懒加载的实现原理\"},{\"text\":\"对防抖和节流的理解\",\"link\":\"/javascript/optimize/#对防抖和节流的理解\"}]}],\"html\":[{\"text\":\"基础\",\"items\":[{\"text\":\"对HTML语义化的理解\",\"link\":\"/html/#对html语义化的理解\"}]},{\"text\":\"性能优化&体验优化\",\"items\":[{\"text\":\"在HTML中延迟加载JavaScript脚本的方式有哪些\",\"link\":\"/html/#在HTML中延迟加载JavaScript脚本的方式有哪些\"},{\"text\":\"重排与重绘概念及触发操作\",\"links\":\"/html/#重排与重绘概念及触发操作\"},{\"text\":\"如何减少重排与重绘\",\"link\":\"/html/#如何减少重排与重绘\"},{\"text\":\"如何提高web可访问性\",\"link\":\"/html/#如何提高web可访问性\"}]}],\"css\":[{\"text\":\"Basics\",\"items\":[{\"text\":\"说说对CSS层叠上下文的理解\",\"link\":\"/css/#说说对CSS层叠上下文的理解\"}]},{\"text\":\"Image\",\"items\":[{\"text\":\"图片布局：实现图片木桶布局（原百度图片布局方式）\",\"link\":\"/css/#图片布局：实现图片木桶布局（原百度图片布局方式）\"}]},{\"text\":\"Optimize\",\"items\":[{\"text\":\"CSS优化和提升性能的方法\",\"link\":\"/css/#css优化和提升性能的方法\"},{\"text\":\"如何通过CSS开启硬件加速来提高网站性能\",\"link\":\"/css/#如何通过CSS开启硬件加速来提高网站性能\"}]}],\"typescript\":[{\"text\":\"基础\",\"items\":[{\"text\":\"TypeScript及静态类型语言的优缺点\",\"link\":\"/vue/#typescript及静态类型语言的优缺点\"},{\"text\":\"TypeScript及静态类型语言的优缺点\",\"link\":\"/vue/#typescript及静态类型语言的优缺点\"}]}],\"vue\":[{\"text\":\"基本原理\",\"items\":[{\"text\":\"Vue的基本原理\",\"link\":\"/vue/#vue的基本原理\"},{\"text\":\"双向数据绑定的原理\",\"link\":\"/vue/#双向数据绑定的原理\"},{\"text\":\"MVVM MVC MVP 的区别\",\"link\":\"/vue/#mvvm-mvc-mvp-的区别\"},{\"text\":\"Vue模板编译原理\",\"link\":\"/vue/#vue模板编译原理\"},{\"text\":\"对Vue组件化的理解\",\"link\":\"/vue/#对vue组件化的理解\"},{\"text\":\"对Vue设计原则的理解\",\"link\":\"/vue/#对vue设计原则的理解\"},{\"text\":\"说说Vue的生命周期\",\"link\":\"/vue/#说说vue的生命周期\"},{\"text\":\"created和mounted区别\",\"link\":\"/vue/#created和mounted区别\"},{\"text\":\"slot的作用及原理\",\"link\":\"/vue/#slot的作用及原理\"},{\"text\":\"nexttick原理及作用\",\"link\":\"/vue/#nexttick原理及作用\"},{\"text\":\"Vue子组件和父组件执行顺序\",\"link\":\"/vue/#vue子组件和父组件执行顺序\"},{\"text\":\"一般在哪个生命周期请求异步数据\",\"link\":\"/vue/#一般在哪个生命周期请求异步数据\"},{\"text\":\"keep-alive中的生命周期哪些\",\"link\":\"/vue/#keep-alive中的生命周期哪些\"},{\"text\":\"子组件可以直接改变父组件的数据吗\",\"link\":\"/vue/#子组件可以直接改变父组件的数据吗\"},{\"text\":\"对React和Vue的理解并比较他们的异同\",\"link\":\"/vue/#对react和vue的理解并比较他们的异同\"},{\"text\":\"Vue的优点\",\"link\":\"/vue/#vue的优点\"},{\"text\":\"Vue3的新变化\",\"link\":\"/vue/#vue3的新变化\"},{\"text\":\"defineProperty和proxy的区别\",\"link\":\"/vue/#defineProperty和proxy的区别\"},{\"text\":\"Vue3为什么要用Proxy\",\"link\":\"/vue/#vue3为什么要用proxy\"},{\"text\":\"虚拟DOM的解析过程\",\"link\":\"/vue/#虚拟dom的解析过程\"},{\"text\":\"diff算法原理\",\"link\":\"/vue/#diff算法原理\"},{\"text\":\"Vue中key的作用\",\"link\":\"/vue/#vue中key的作用\"}]},{\"text\":\"Vuex\",\"items\":[{\"text\":\"Vuex的基本原理\",\"link\":\"/vue/vuex/#vuex的基本原理\"},{\"text\":\"Vuex和localStorage区别\",\"link\":\"/vue/vuex/#vuex和localstorage区别\"},{\"text\":\"Vuex和Redux的异同\",\"link\":\"/vue/vuex/#vuex和redux的异同\"},{\"text\":\"为什么使用Vuex或Redux\",\"link\":\"/vue/vuex/#为什么使用vuex或redux\"},{\"text\":\"Vuex有哪几种属性\",\"link\":\"/vue/vuex/#vuex有哪几种属性\"},{\"text\":\"Vuex和单纯的全局对象有什么区别\",\"link\":\"/vue/vuex/#vuex和单纯的全局对象有什么区别\"},{\"text\":\"为什么Vuex的mutation中不能做异步操作\",\"link\":\"/vue/vuex/#为什么vuex的mutation中不能做异步操作\"}]},{\"text\":\"Vue Router\",\"items\":[{\"text\":\"路由的hash和history模式区别\",\"link\":\"/vue/vue-router/#路由的hash和history模式区别\"},{\"text\":\"vue-router跳转和location.href有什么区别\",\"link\":\"/vue/vue-router/#vue-router跳转和location-href有什么区别\"}]}],\"engineering\":[{\"text\":\"Package Management\",\"items\":[{\"text\":\"npm、yarn与pnpm的区别\",\"link\":\"/engineering/#npmyarn与pnpm的区别\"}]},{\"text\":\"Webpack\",\"items\":[{\"text\":\"如何⽤webpack来优化前端性能\",\"links\":\"/engineering/#如何⽤webpack来优化前端性能\"},{\"text\":\"如何提高webpack构建速度\",\"links\":\"/engineering/#如何提高webpack构建速度\"},{\"text\":\"webpack常用的loader\",\"links\":\"/engineering/#webpack常用的loader\"},{\"text\":\"webpack常用的plugin\",\"links\":\"/engineering/#webpack常用的plugin\"},{\"text\":\"bundle，chunk，module是什么\",\"links\":\"/engineering/#bundle-chunk-module是什么\"},{\"text\":\"webpack中loader和plugin的不同\",\"links\":\"/engineering/#webpack中loader和plugin的不同\"},{\"text\":\"webpack热更新的原理\",\"links\":\"/engineering/#webpack热更新的原理\"}]},{\"text\":\"Babel\",\"items\":[{\"text\":\"babel原理\",\"link\":\"/engineering/#babel原理\"}]},{\"text\":\"前端监控\",\"items\":[{\"text\":\"设计实现前端埋点SDK\",\"link\":\"/engineering/#设计实现前端埋点sdk\"}]}]},\"footer\":{\"license\":{\"text\":\"MIT License\",\"link\":\"https://opensource.org/licenses/MIT\"},\"copyright\":\"Copyright © 2022-2023 <a href=\\\"https://github.com/alisalicn\\\" target=\\\"_blank\\\">Alisa Li</a>\"}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}");</script>
    
  </body>
</html>